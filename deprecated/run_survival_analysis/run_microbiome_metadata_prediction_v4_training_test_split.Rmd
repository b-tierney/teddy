---
title: "run_microbiome_metadata_predictions_v3"
author: "Sam Zimmerman"
date: "2022-08-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#Functionalize everything!

```{r}
library(dplyr)
library(survival)
library(timeROC)
library(ggplot2)
library(RNOmni)
library(cowplot)
library(pROC)
# condition_type can be seroconversion, MIAA, GAD, IA2A, T1D

prepare_inputs = function(microbome_abundance_file,metadata_file,condition_type) {
  microbiome_abundances = read.csv(microbome_abundance_file)
  rownames(microbiome_abundances) = microbiome_abundances[,1]
  microbiome_abundances = microbiome_abundances[,-1]
  sample_metadata = read.csv(metadata_file)
  sample_metadata = sample_metadata[-which(is.na(sample_metadata$GRS_score)),]
  metadata_abundance_samples= intersect(colnames(microbiome_abundances),sample_metadata$Run)
  microbiome_abundances_intersection = microbiome_abundances[,metadata_abundance_samples]
  sample_metadata_ordered = sample_metadata[match(metadata_abundance_samples,sample_metadata$Run),]

  # summarize metadata so I have an observation per subject. get subject level metadata. use t1d/auntoantibody times if subject gets T1D/autoantibody. else use last time of followup
  sample_metadata_ordered_split = split(sample_metadata_ordered,sample_metadata_ordered$m138_maskid)
  subject_metadata_ordered= do.call("rbind",lapply(sample_metadata_ordered_split, function(subject) {
    if(condition_type == "T1D") {
      hasCondition = unique(subject$t1d)
    } else if(condition_type == "seroconversion") {
      hasCondition = unique(subject$two_persist_conf)
    } else if(condition_type == "MIAA") {
      hasCondition = unique(subject$MIAA_pos)
    } else if (condition_type == "GAD") {
      hasCondition = unique(subject$GAD_pos)
    } else if (condition_type == "IA2A") {
      hasCondition = unique(subject$IA2A_pos)
    }
    fdr = unique(subject$fdr)
    grs2 = unique(subject$GRS_score)
    if(hasCondition == TRUE & condition_type == "T1D") {
      time = unique(subject$age_t1d)
    } else if(hasCondition == TRUE & condition_type == "seroconversion") {
      time = unique(subject$age_mult_persist)
    } else if(hasCondition == TRUE & condition_type == "MIAA") {
      time = unique(subject$age_first_MIAA)
    } else if(hasCondition == TRUE & condition_type == "GAD") {
      time = unique(subject$age_first_GAD)
    } else if(hasCondition == TRUE & condition_type == "IA2A") {
      time = unique(subject$age_first_IA2A)
    } else {
      chosen_subject = subject[which.max(subject$age_at_collection),]
      time = unique(chosen_subject$age_at_collection)
    }
    return(c(time,hasCondition,fdr,grs2))  
  }))
  subject_metadata_ordered = as.data.frame(subject_metadata_ordered)
  colnames(subject_metadata_ordered) = c("time","getsCondition","fdr","grs2")
  return(list(subject_metadata=subject_metadata_ordered,sample_metadata = sample_metadata_ordered,abundance_data=microbiome_abundances_intersection))
}

# function that removes subjects who were censored or had T1D before landmark time
get_landmark_db = function(mydf,day_begin_temp) {
  bool_temp = which(mydf$time < day_begin_temp)
  if(length(bool_temp) >0) {
    newDF = mydf[-bool_temp,]
    return(newDF)
  } else {
    return(mydf)
  }
}

getAUCs = function(sample_metadata,subject_metada,microbe_abundances,day_beginv,day_endv,train_subject_file,test_subject_file,min_vars_to_keep,max_vars_to_keep) {
AUC_m_1_with_microbiome_train <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
AUC_m_1_with_microbiome_test <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
AUC_all_times_vec_train = rep(0,length(day_beginv))
AUC_all_times_vec_test = rep(0,length(day_beginv))
cox_coef_list_train = list()
#coef_list = list()
set.seed(1986)

for (x_count in 1:length(day_beginv)) {
  print(x_count)
  min_vars_to_keep_temp = min_vars_to_keep
  max_vars_to_keep_temp = max_vars_to_keep
  begin_time = day_beginv[x_count]
  day_end = begin_time + day_endv
  
  # remove those that have T1D before landmark time
  all_prediction_metadata_yearx = get_landmark_db(subject_metada,begin_time)
  
  # get autoantibodies, family hist, and GRS2 at landmark time
  young_enough = sample_metadata$age_at_collection <= begin_time
  # get metadata below landmark time and for those that do not have T1D before landmark time
  wont_get_t1D_before_landmark = sample_metadata$m138_maskid%in%rownames(all_prediction_metadata_yearx)
  
  metadata_temp = sample_metadata[young_enough & wont_get_t1D_before_landmark,]
  # get abundance samples below landmark time
  abundance_data_temp = microbe_abundances[,metadata_temp$Run]
  # now get autoantibodies per subject
  num_autoantibodies_per_subj = sapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    oldest_samp = unlist(df_temp[which.max(as.numeric(df_temp$age_at_collection)),])
    oldest_age = as.numeric(oldest_samp["age_at_collection"])
    had_MIAA <- oldest_age >= as.numeric(oldest_samp["age_first_MIAA"])
    if(is.na(had_MIAA)) {
      had_MIAA = FALSE
    }
    had_GAD <- oldest_age >= as.numeric(oldest_samp["age_first_GAD"])
    if(is.na(had_GAD)) {
      had_GAD = FALSE
    }
    had_IA2A <- oldest_age >= as.numeric(oldest_samp["age_first_IA2A"])
    if(is.na(had_IA2A)) {
      had_IA2A = FALSE
    }
    num_autoantibodies_had = sum(as.numeric(c(had_MIAA,had_GAD,had_IA2A)))
    return(num_autoantibodies_had)
  })
  
  # get the average abundance of microbiome gene for each subject before landmark time
  abundance_data_temp_subject = lapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    runs_temp = df_temp$Run
    return(rowMeans(abundance_data_temp[,runs_temp,drop=FALSE]))
  })
  abundance_data_temp_subject_df = do.call("rbind",abundance_data_temp_subject)
  abundance_data_temp_subject_df = apply(abundance_data_temp_subject_df, 2, function(x) RankNorm(x))
  
  # add antibody number to metadata
  all_prediction_metadata_yearx$num_autoantibodies = num_autoantibodies_per_subj[match(rownames(all_prediction_metadata_yearx),names(num_autoantibodies_per_subj))]
  # NA antibodies are 0
  all_prediction_metadata_yearx$num_autoantibodies[is.na(all_prediction_metadata_yearx$num_autoantibodies)] = 0
  # make fdr and autoantibodies factors
  if(length(unique(all_prediction_metadata_yearx$fdr)) >1) {
    all_prediction_metadata_yearx$fdr = as.factor(all_prediction_metadata_yearx$fdr)
  }
  if(length(unique(all_prediction_metadata_yearx$num_autoantibodies)) >1) {
    all_prediction_metadata_yearx$num_autoantibodies = as.factor(all_prediction_metadata_yearx$num_autoantibodies)
  }
  
  # now add microbiome data
  abundance_data_temp_subject_df = abundance_data_temp_subject_df[match(rownames(all_prediction_metadata_yearx),rownames(abundance_data_temp_subject_df)),]
  # any NAs are because we don't have samples at landmark time 
  all_prediction_metadata_yearx_withMicrobiome = cbind(all_prediction_metadata_yearx,abundance_data_temp_subject_df)
  # remove samples where I don't have microbiome data for it
  all_prediction_metadata_yearx_withMicrobiome = all_prediction_metadata_yearx_withMicrobiome[!is.na(all_prediction_metadata_yearx_withMicrobiome[,6]),]
  # what if instead of removing samples I say value is 0 
  #all_prediction_metadata_yearx_withMicrobiome[is.na(all_prediction_metadata_yearx_withMicrobiome)] = 0
  
  # now split into train and test sets
  
  train_subjects = read.table(train_subject_file)
  train_subjects = train_subjects[,1]
  test_subjects = read.table(test_subject_file)
  test_subjects = test_subjects[,1]

  train_subjects_to_keep = intersect(train_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  test_subects_to_keep = intersect(test_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  # scale grs2 score before splitting
  all_prediction_metadata_yearx_withMicrobiome$grs2 = scale(all_prediction_metadata_yearx_withMicrobiome$grs2)
  all_prediction_metadata_yearx_withMicrobiome <- model.matrix( ~. , all_prediction_metadata_yearx_withMicrobiome)
  all_prediction_metadata_yearx_withMicrobiome = all_prediction_metadata_yearx_withMicrobiome[,-1]

  if("num_autoantibodies"%in%min_vars_to_keep_temp) {
    num_atoantibody_cols = colnames(all_prediction_metadata_yearx_withMicrobiome)[grep("num_autoantibodies",colnames(all_prediction_metadata_yearx_withMicrobiome))]
    min_vars_to_keep_temp = c(min_vars_to_keep_temp,num_atoantibody_cols)
    min_vars_to_keep_temp = min_vars_to_keep_temp[-match("num_autoantibodies",min_vars_to_keep_temp)]
  }
  if("fdr"%in%min_vars_to_keep_temp) {
    fdr_cols = colnames(all_prediction_metadata_yearx_withMicrobiome)[grep("fdr",colnames(all_prediction_metadata_yearx_withMicrobiome))]
    min_vars_to_keep_temp = c(min_vars_to_keep_temp,fdr_cols)
    min_vars_to_keep_temp = min_vars_to_keep_temp[-match("fdr",min_vars_to_keep_temp)]
  }
  
  if("num_autoantibodies"%in%max_vars_to_keep_temp) {
    num_atoantibody_cols = colnames(all_prediction_metadata_yearx_withMicrobiome)[grep("num_autoantibodies",colnames(all_prediction_metadata_yearx_withMicrobiome))]
    max_vars_to_keep_temp = c(max_vars_to_keep_temp,num_atoantibody_cols)
    max_vars_to_keep_temp = max_vars_to_keep_temp[-match("num_autoantibodies",max_vars_to_keep_temp)]
  }
  if("fdr"%in%max_vars_to_keep_temp) {
    fdr_cols = colnames(all_prediction_metadata_yearx_withMicrobiome)[grep("fdr",colnames(all_prediction_metadata_yearx_withMicrobiome))]
    max_vars_to_keep_temp = c(max_vars_to_keep_temp,fdr_cols)
    max_vars_to_keep_temp = max_vars_to_keep_temp[-match("fdr",max_vars_to_keep_temp)]
  }
  
  all_prediction_metadata_yearx_withMicrobiome_train = all_prediction_metadata_yearx_withMicrobiome[train_subjects_to_keep,]
  all_prediction_metadata_yearx_withMicrobiome_test = all_prediction_metadata_yearx_withMicrobiome[test_subects_to_keep,]

  #variables_for_prediction = c("fdr","num_autoantibodies","grs2") min_vars_to_keep max_vars_to_keep
  
  ## do stepwise selection to choose important microbiome genes. 
    #variables_for_prediction_plus_microbiome = c(variables_for_prediction,colnames(abundance_data_temp_subject_df))
  #model_train_min <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  #model_train_max <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))

    
  #my_formula1_max_vars <- paste0("~",paste(max_vars_to_keep, collapse = " + "))
  #my_formula_2_min_vars <- paste0("~",paste(min_vars_to_keep, collapse = " + "))
  #my_formula1_max_vars<- as.formula(paste("Surv(time,getsCondition)",my_formula1_max_vars,sep=""))
  #my_formula_2_min_vars<- as.formula(paste("Surv(time,getsCondition)",my_formula_2_min_vars,sep=""))
  
  #library(caret)
  #library(leaps)
  #library(MASS)
  #model_train_min <- coxph(my_formula_2_min_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  #model_train_max <- coxph(my_formula1_max_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  
  all_prediction_metadata_yearx_withMicrobiome_train_y = all_prediction_metadata_yearx_withMicrobiome_train[,c("time","getsCondition")]
  colnames(all_prediction_metadata_yearx_withMicrobiome_train_y) = c("time","status")
  all_prediction_metadata_yearx_withMicrobiome_train_y = as.matrix(all_prediction_metadata_yearx_withMicrobiome_train_y)
  all_prediction_metadata_yearx_withMicrobiome_train_x = all_prediction_metadata_yearx_withMicrobiome_train[,-match(c("time","getsCondition"),colnames(all_prediction_metadata_yearx_withMicrobiome_train))]
    #all_prediction_metadata_yearx_withMicrobiome_train_x$fdr = as.numeric(as.character(all_prediction_metadata_yearx_withMicrobiome_train_x$fdr))
    #all_prediction_metadata_yearx_withMicrobiome_train_x$num_autoantibodies = as.numeric(as.character(all_prediction_metadata_yearx_withMicrobiome_train_x$num_autoantibodies))

  all_prediction_metadata_yearx_withMicrobiome_train_x = all_prediction_metadata_yearx_withMicrobiome_train_x[,max_vars_to_keep_temp]
  if(identical(min_vars_to_keep,max_vars_to_keep)) {
    my_formula_2_min_vars <- paste0("~",paste(min_vars_to_keep_temp, collapse = " + "))
    my_formula_2_min_vars<- as.formula(paste("Surv(time,getsCondition)",my_formula_2_min_vars,sep=""))
    all_prediction_metadata_yearx_withMicrobiome_train = as.data.frame(all_prediction_metadata_yearx_withMicrobiome_train)
    model_train_min <- coxph(my_formula_2_min_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
    predict_train <- predict(model_train_min, all_prediction_metadata_yearx_withMicrobiome_train, type = "risk")
    all_prediction_metadata_yearx_withMicrobiome_test = as.data.frame(all_prediction_metadata_yearx_withMicrobiome_test)
    predict_test = predict(model_train_min, all_prediction_metadata_yearx_withMicrobiome_test, type="risk")
    train_coefs = model_train_min$coefficients
  } else {
    all_prediction_metadata_yearx_withMicrobiome_train_x = as.matrix(all_prediction_metadata_yearx_withMicrobiome_train_x)
    penalty_factor = rep(1,ncol(all_prediction_metadata_yearx_withMicrobiome_train_x))
    penalty_factor[colnames(all_prediction_metadata_yearx_withMicrobiome_train_x)%in%min_vars_to_keep_temp] = 0
    cv_output <- cv.glmnet(all_prediction_metadata_yearx_withMicrobiome_train_x, all_prediction_metadata_yearx_withMicrobiome_train_y,alpha = 1, nfolds = 5,family="cox",penalty.factor=penalty_factor,type.measure="C")
    # identifying best lamda
    best_lam <- cv_output$lambda.min
    train_coefs = coef(cv_output,s=best_lam)
    train_coefs = train_coefs[abs(train_coefs[,1])>0,]
  
    predict_train = predict(cv_output, newx = all_prediction_metadata_yearx_withMicrobiome_train_x, s = "lambda.min")
  
    # get test set
      all_prediction_metadata_yearx_withMicrobiome_test_x = all_prediction_metadata_yearx_withMicrobiome_test[,-match(c("time","getsCondition"),colnames(all_prediction_metadata_yearx_withMicrobiome_test))]
    all_prediction_metadata_yearx_withMicrobiome_test_x = all_prediction_metadata_yearx_withMicrobiome_test_x[,max_vars_to_keep_temp]

    all_prediction_metadata_yearx_withMicrobiome_test_x = as.matrix(all_prediction_metadata_yearx_withMicrobiome_test_x)

    predict_test = predict(cv_output, newx = all_prediction_metadata_yearx_withMicrobiome_test_x, s = "lambda.min")
  }
  ROC.T_train <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_train[,"time"],
            delta = all_prediction_metadata_yearx_withMicrobiome_train[,"getsCondition"],marker = predict_train,
            cause = 1, weighting = "marginal",
            times = day_end,
            iid = FALSE) # set to false for now
  ROC.T_test <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_test[,"time"],
            delta = all_prediction_metadata_yearx_withMicrobiome_test[,"getsCondition"],marker = predict_test,
            cause = 1, weighting = "marginal",
            times = day_end,
            iid = FALSE) # set to false for now
  
  #train.control <- trainControl(method = "cv", number = 5)
  
  #step.model <- train(my_formula1_max_vars, data = all_prediction_metadata_yearx_withMicrobiome_train,
  #                  method = "leapForward",
  #                  trControl = train.control
  #                  )

  #res.cox_train = tryCatch({
  #res.cox_train = step(model_train_min,scope = list(upper=my_formula1_max_vars,lower=my_formula_2_min_vars), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
#},error = function(e) {
#        #coefs = summary(model_train_min)$coefficients
#        res.cox_train = step(model_train_min,scope = list(upper=formula(model_train_min),lower=formula(model_train_min)), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
#        return(res.cox_train)
#})
  
  #my_solution = step(model_train_min,scope = list(upper=formula(model_train_max),lower=formula(model_train_min)), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
  
#  coefs = summary(res.cox_train)$coefficients
  #coef_list[[x_count]] = coefs
  
  #metadata_coef_pos = unlist(sapply(c("fdr","num_autoantibodies","grs2"), function(var) grep(var,rownames(coefs))))
  
  #microbiome_coefs = coefs[-metadata_coef_pos,,drop=FALSE]
  
#  microbiome_coefs = coefs[rownames(coefs)%in%rownames(microbe_abundances),]
  
#  microbiome_coefs = rownames(microbiome_coefs)
  
  # now that I have my variables do predictions
  
  #variables_for_prediction_with_microbiome = rownames(coefs)
  
  #my_formula <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction_with_microbiome, collapse = " + ")))
  
  
  #res.cox_train <- coxph(my_formula, data = all_prediction_metadata_yearx_withMicrobiome_train)
  
  cox_coef_list_train[[x_count]] = train_coefs
  
  # extract linear predition in the log hazard function
  #marker_score_train <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_train, type = "risk")
  #marker_score_test <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_test, type = "risk")
  #delta_train <- all_prediction_metadata_yearx_withMicrobiome_train[["getsCondition"]]
  #delta_test <- all_prediction_metadata_yearx_withMicrobiome_test[["getsCondition"]]
  #ROC.T_train <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_train$time,
  #            delta = delta_train,marker = marker_score_train,
  #            cause = 1, weighting = "marginal",
  #            times = day_end,
  #            iid = FALSE) # set to false for now
  #ROC.T_test <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_test$time,
  #            delta = delta_test,marker = marker_score_test,
  #            cause = 1, weighting = "marginal",
  #            times = day_end,
  #            iid = FALSE) # set to false for now
  
  #ROC_test_all_times = as.numeric(roc(delta_test, marker_score_test)$auc)
  #ROC_train_all_times = as.numeric(roc(delta_train, marker_score_train)$auc)
  
  #AUC_all_times_vec_train[x_count] = ROC_train_all_times
  #AUC_all_times_vec_test[x_count] = ROC_test_all_times

  AUC_m_1_with_microbiome_train[x_count,] = ROC.T_train$AUC
  AUC_m_1_with_microbiome_test[x_count,] = ROC.T_test$AUC
}
  return(list(AUC_m_1_with_microbiome_train,AUC_m_1_with_microbiome_test,cox_coef_list_train))
}

make_plots = function(prediction_auc_list) {
  train_aucs = prediction_auc_list[[1]]
  test_aucs = prediction_auc_list[[2]]
  prediction_at = c(0.25,0.6,1,1.5,2,2.5,3)
  prediction_for <- c(1,3,5,8)
  rownames(train_aucs) = prediction_at
  rownames(test_aucs) = prediction_at
  colnames(train_aucs) = prediction_for
  colnames(test_aucs) = prediction_for
  
  test_aucs_melt = reshape2::melt(test_aucs)
  train_aucs_melt = reshape2::melt(train_aucs)
  colnames(test_aucs_melt) = c("Landscape","Horizon","AUC")
  colnames(train_aucs_melt) = c("Landscape","Horizon","AUC")
  train_aucs_melt$type = "train"
  test_aucs_melt$type = "test"
  train_aucs_melt$Horizon = as.factor(train_aucs_melt$Horizon)
  test_aucs_melt$Horizon = as.factor(train_aucs_melt$Horizon)
  aucs_df = rbind(train_aucs_melt,test_aucs_melt)
  aucs_df$type = as.factor(aucs_df$type)
  plotA = ggplot(train_aucs_melt,aes(x=Landscape,y=AUC,group=Horizon)) + geom_line(aes(color=Horizon)) + geom_point(aes(color=Horizon)) + theme_bw() + ylim(0,1)
  plotB = ggplot(test_aucs_melt,aes(x=Landscape,y=AUC,group=Horizon)) + geom_line(aes(color=Horizon)) + geom_point(aes(color=Horizon)) + theme_bw() + ylim(0,1)
  myplots = plot_grid(plotA, plotB, labels = c("train","test"))
  return(myplots)
}

```

#Run FUnctions to do T1D predictions

```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

T1D_training_subjects = "~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.train_subjects.txt"
T1D_testing_subjects = "~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.test_subjects.txt"


T1D_input_DFs =  prepare_inputs(microbome_abundance_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/lasso_sig_genes_from_training_data_raw_abundance_data_healthy_pre-t1d-all_HLA.csv",metadata_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/analysis_old_assembly_alignment/teddy_old_analysis/teddy_metadata_20190821_with_GRS2.csv",condition_type = "T1D")

T1D_sample_metadata = T1D_input_DFs[["sample_metadata"]]
T1D_subject_metadata = T1D_input_DFs[["subject_metadata"]]
T1D_abundance_data = T1D_input_DFs[["abundance_data"]]

min_vars_to_keep = c("fdr","num_autoantibodies","grs2")
max_vars_to_keep = c("fdr","num_autoantibodies","grs2",rownames(T1D_abundance_data))


clincal_and_microbe_AUCs = getAUCs(sample_metadata=T1D_sample_metadata, subject_metada=T1D_subject_metadata,microbe_abundances=T1D_abundance_data,day_beginv,day_endv,train_subject_file=T1D_training_subjects,test_subject_file=T1D_testing_subjects,min_vars_to_keep,max_vars_to_keep)

clincal_AUCs = getAUCs(sample_metadata=T1D_sample_metadata, subject_metada=T1D_subject_metadata,microbe_abundances=T1D_abundance_data,day_beginv,day_endv,train_subject_file=T1D_training_subjects,test_subject_file=T1D_testing_subjects,min_vars_to_keep=min_vars_to_keep,max_vars_to_keep=min_vars_to_keep)

microbe_AUCs = getAUCs(sample_metadata=T1D_sample_metadata, subject_metada=T1D_subject_metadata,microbe_abundances=T1D_abundance_data,day_beginv,day_endv,train_subject_file=T1D_training_subjects,test_subject_file=T1D_testing_subjects,min_vars_to_keep=(1),max_vars_to_keep=rownames(T1D_abundance_data))


make_plots(microbe_AUCs)
make_plots(clincal_and_microbe_AUCs)
make_plots(clincal_AUCs)

```


#Now do MIAA predictions

```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

MIAA_training_subjects = "~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-MIAA.train_subjects.txt"
MIAA_testing_subjects = "~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-MIAA.test_subjects.txt"

MIAA_input_DFs =  prepare_inputs(microbome_abundance_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/top_lasso_sig_genes_sample_abundances_MIAA.csv",metadata_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/analysis_old_assembly_alignment/teddy_old_analysis/teddy_metadata_20190821_with_GRS2.csv",condition_type = "MIAA")

MIAA_sample_metadata = MIAA_input_DFs[["sample_metadata"]]
MIAA_subject_metadata = MIAA_input_DFs[["subject_metadata"]]
MIAA_abundance_data = MIAA_input_DFs[["abundance_data"]]

microbe_AUCs_MIAA = getAUCs(sample_metadata=MIAA_sample_metadata, subject_metada=MIAA_subject_metadata,microbe_abundances=MIAA_abundance_data,day_beginv,day_endv,train_subject_file=MIAA_training_subjects,test_subject_file=MIAA_testing_subjects,min_vars_to_keep=(1),max_vars_to_keep=rownames(MIAA_abundance_data))

pdf("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/predicting_MIAA_with_microbiome.pdf")
make_plots(microbe_AUCs_MIAA)
dev.off()

```








#Process data to get ready for prediction

```{r}
library(dplyr)
library(survival)
library(timeROC)
library(ggplot2)

# condition_type can be seroconversion, MIAA, GAD, IA2A, T1D

prepare_inputs = function(microbome_abundance_file,metadata_file,condition_type) {
  microbiome_abundances = read.csv(microbome_abundance_file)
  rownames(microbiome_abundances) = microbiome_abundances[,1]
  microbiome_abundances = microbiome_abundances[,-1]
  sample_metadata = read.csv(metadata_file)
  sample_metadata = sample_metadata[-which(is.na(sample_metadata$GRS_score)),]
  metadata_abundance_samples= intersect(colnames(microbiome_abundances),sample_metadata$Run)
  microbiome_abundances_intersection = microbiome_abundances[,metadata_abundance_samples]
  sample_metadata_ordered = sample_metadata[match(metadata_abundance_samples,sample_metadata$Run),]

  # summarize metadata so I have an observation per subject. get subject level metadata. use t1d/auntoantibody times if subject gets T1D/autoantibody. else use last time of followup
  sample_metadata_ordered_split = split(sample_metadata_ordered,sample_metadata_ordered$m138_maskid)
  subject_metadata_ordered= do.call("rbind",lapply(sample_metadata_ordered_split, function(subject) {
    if(condition_type == "T1D") {
      hasCondition = unique(subject$t1d)
    } else if(condition_type == "seroconversion") {
      hasCondition = unique(subject$two_persist_conf)
    } else if(condition_type == "MIAA") {
      hasCondition = age_first_MIAA$MIAA_pos
    } else if (condition_type == "GAD") {
      hasCondition = age_first_MIAA$GAD_pos
    } else if (condition_type == "IA2A") {
      hasCondition = age_first_MIAA$IA2A_pos
    }
    fdr = unique(subject$fdr)
    grs2 = unique(subject$GRS_score)
    if(hasCondition == TRUE & condition_type == "T1D") {
      time = unique(subject$age_t1d)
    } else if(hasCondition == TRUE & condition_type == "seroconversion") {
      time = unique(subject$age_mult_persist)
    } else if(hasCondition == TRUE & condition_type == "MIAA") {
      time = unique(subject$age_first_MIAA)
    } else if(hasCondition == TRUE & condition_type == "GAD") {
      time = unique(subject$age_first_GAD)
    } else if(hasCondition == TRUE & condition_type == "IA2A") {
      time = unique(subject$age_first_IA2A)
    } else {
      chosen_subject = subject[which.max(subject$age_at_collection),]
      time = unique(chosen_subject$age_at_collection)
    }
    return(c(time,hasCondition,fdr,grs2))  
  }))
  subject_metadata_ordered = as.data.frame(subject_metadata_ordered)
  colnames(subject_metadata_ordered) = c("time","getsCondition","fdr","grs2")
  return(list(metadata=subject_metadata_ordered,abundance_data=microbiome_abundances_intersection))
}

health_pre_T1D_input_dfs = prepare_inputs(microbome_abundance_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/lasso_sig_genes_from_training_data_raw_abundance_data_healthy_pre-t1d-all_HLA.csv",metadata_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/analysis_old_assembly_alignment/teddy_old_analysis/teddy_metadata_20190821_with_GRS2.csv",condition_type = "T1D")









# read in abundance data
microbiome_abundances = read.csv("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/lasso_sig_genes_from_training_data_raw_abundance_data_healthy_pre-t1d-all_HLA.csv")
rownames(microbiome_abundances) = microbiome_abundances[,1]
microbiome_abundances = microbiome_abundances[,-1]

# get sample metadata
sample_metadata = read.csv("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/analysis_old_assembly_alignment/teddy_old_analysis/teddy_metadata_20190821_with_GRS2.csv")
# only include samples I have GRS score for
sample_metadata = sample_metadata[-which(is.na(sample_metadata$GRS_score)),]

# get samples we have metadata and abundance data for

metadata_abundance_samples= intersect(colnames(microbiome_abundances),sample_metadata$Run)

microbiome_abundances_intersection = microbiome_abundances[,metadata_abundance_samples]
sample_metadata_ordered = sample_metadata[match(metadata_abundance_samples,sample_metadata$Run),]

# summarize metadata so I have an observation per subject. get subject level metadata. use t1d times if subject gets T1D. else use last time of followup
sample_metadata_ordered_split = split(sample_metadata_ordered,sample_metadata_ordered$m138_maskid)
subject_metadata_ordered= do.call("rbind",lapply(sample_metadata_ordered_split, function(subject) {
  hasT1D = unique(subject$t1d)
  fdr = unique(subject$fdr)
  grs2 = unique(subject$GRS_score)
  if(hasT1D == TRUE) {
    time = unique(subject$age_t1d)
  } else {
    chosen_subject = subject[which.max(subject$age_at_collection),]
    time = unique(chosen_subject$age_at_collection)
  }
  return(c(time,hasT1D,fdr,grs2))  
}))
subject_metadata_ordered = as.data.frame(subject_metadata_ordered)
colnames(subject_metadata_ordered) = c("time","getsT1D","fdr","grs2")


```

#Predictions for microbiome only

```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

# function that removes subjects who were censored or had T1D before landmark time
get_landmark_db = function(mydf,day_begin_temp) {
  bool_temp = which(mydf$time < day_begin_temp)
  if(length(bool_temp) >0) {
    newDF = mydf[-bool_temp,]
    return(newDF)
  } else {
    return(mydf)
  }
}

create_IC_se <- function(table,table_se,confidencev=1.96, class){
  n1 <- dim(table)[1]
  n2 <- dim(table)[2]
  output <- matrix(NA, nrow = n1, ncol = n2)
  for (i in 1:n1) {
    for (j in 1:n2) {
      if (class == "up") {
        output[i,j] <- min(table[i,j] + confidencev * table_se[i,j],1)
      }
      else{
        output[i,j] <- max(table[i,j] - confidencev * table_se[i,j],0)
      }
    }
  }
  rownames(output) <-  rownames(table)
  colnames(output) <-  colnames(table)
    return(output)
}


#n_nested = 10

AUC_m_1_microbiome_only_train <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
AUC_m_1_microbiome_only_test <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))

#seAUC_m_1_microbiome_only <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))

set.seed(1986)

for (x_count in 1:length(day_beginv)) {
  begin_time = day_beginv[x_count]
  day_end = begin_time + day_endv
  
  # remove those that have T1D before landmark time
  all_prediction_metadata_yearx = get_landmark_db(subject_metadata_ordered,begin_time)
  
  # get autoantibodies, family hist, and GRS2 at landmark time
  young_enough = sample_metadata_ordered$age_at_collection <= begin_time
  # get metadata below landmark time and for those that do not have T1D before landmark time
  wont_get_t1D_before_landmark = sample_metadata_ordered$m138_maskid%in%rownames(all_prediction_metadata_yearx)
  # for subjects included at this landmark, get there visits before or equal to landmark time.
  metadata_temp = sample_metadata_ordered[young_enough & wont_get_t1D_before_landmark,]
  # get abundance samples below landmark time
  abundance_data_temp = microbiome_abundances_intersection[,metadata_temp$Run]

  # get the average abundance of microbiome gene for each subject before landmark time
  abundance_data_temp_subject = lapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    runs_temp = df_temp$Run
    return(rowMeans(abundance_data_temp[,runs_temp,drop=FALSE]))
  })
  abundance_data_temp_subject_df = do.call("rbind",abundance_data_temp_subject)
  abundance_data_temp_subject_df = apply(abundance_data_temp_subject_df, 2, function(x) RankNorm(x))
  
  # now add microbiome data
  abundance_data_temp_subject_df = abundance_data_temp_subject_df[match(rownames(all_prediction_metadata_yearx),rownames(abundance_data_temp_subject_df)),]
  # any NAs are because we don't have samples at landmark time 
  all_prediction_metadata_yearx_withMicrobiome = cbind(all_prediction_metadata_yearx,abundance_data_temp_subject_df)
  # remove samples where I don't have microbiome data for it
  all_prediction_metadata_yearx_withMicrobiome = all_prediction_metadata_yearx_withMicrobiome[!is.na(all_prediction_metadata_yearx_withMicrobiome[,6]),]
  # what if instead of removing samples I say value is 0 
  #all_prediction_metadata_yearx_withMicrobiome[is.na(all_prediction_metadata_yearx_withMicrobiome)] = 0
  
  # now split into train and test sets
  train_subjects = read.table("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.train_subjects.txt")
  train_subjects = train_subjects[,1]
  test_subjects = read.table("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.test_subjects.txt")
  test_subjects = test_subjects[,1]

  train_subjects_to_keep = intersect(train_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  test_subects_to_keep = intersect(test_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  
  all_prediction_metadata_yearx_withMicrobiome_train = all_prediction_metadata_yearx_withMicrobiome[train_subjects_to_keep,]
  all_prediction_metadata_yearx_withMicrobiome_test = all_prediction_metadata_yearx_withMicrobiome[test_subects_to_keep,]

  variables_for_prediction = colnames(abundance_data_temp_subject_df)
  
  ## do stepwise selection to choose important microbiome genes.
  intercept_only_train <- coxph(Surv(time,getsT1D) ~1,data=all_prediction_metadata_yearx_withMicrobiome_train) 
  
  
  all_model_train = coxph(Surv(time,getsT1D) ~.,data=all_prediction_metadata_yearx_withMicrobiome_train[,c("time","getsT1D",colnames(abundance_data_temp_subject_df))]) 
  my_solution <- step(intercept_only_train, direction='forward', scope=formula(all_model_train),k=log(ncol(abundance_data_temp_subject_df)),steps=5000)

  coefs = summary(my_solution)$coefficients
  #coef_list[[x_count]] = coefs
  
  metadata_coef_pos = unlist(sapply(c("fdr","num_autoantibodies","grs2"), function(var) grep(var,rownames(coefs))))
  
  microbiome_coefs = rownames(coefs)

  # now that I have my variables do predictions
  
  variables_for_prediction_with_microbiome = microbiome_coefs
  
  my_formula <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction_with_microbiome, collapse = " + ")))
  
  res.cox_train <- coxph(my_formula, data = all_prediction_metadata_yearx_withMicrobiome_train)
  
  marker_score_train <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_train, type = "risk")
  marker_score_test <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_test, type = "risk")
  delta_test <- all_prediction_metadata_yearx_withMicrobiome_test[["getsT1D"]]
  delta_train <- all_prediction_metadata_yearx_withMicrobiome_train[["getsT1D"]]
  
  ROC.T_test <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_test$time,
            delta = delta_test,marker = marker_score_test,
            cause = 1, weighting = "marginal",
            times = day_end,
            iid = FALSE) # set to false for now

  ROC.T_train <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_train$time,
            delta = delta_train,marker = marker_score_train,
            cause = 1, weighting = "marginal",
            times = day_end,
            iid = FALSE) # set to false for now

  AUC_m_1_microbiome_only_train[x_count,] = ROC.T_train$AUC
  AUC_m_1_microbiome_only_test[x_count,] = ROC.T_test$AUC
}
```


#Now start the predictions for the gene abundance plus microbiome

```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

# function that removes subjects who were censored or had T1D before landmark time
get_landmark_db = function(mydf,day_begin_temp) {
  bool_temp = which(mydf$time < day_begin_temp)
  if(length(bool_temp) >0) {
    newDF = mydf[-bool_temp,]
    return(newDF)
  } else {
    return(mydf)
  }
}

create_IC_se <- function(table,table_se,confidencev=1.96, class){
  n1 <- dim(table)[1]
  n2 <- dim(table)[2]
  output <- matrix(NA, nrow = n1, ncol = n2)
  for (i in 1:n1) {
    for (j in 1:n2) {
      if (class == "up") {
        output[i,j] <- min(table[i,j] + confidencev * table_se[i,j],1)
      }
      else{
        output[i,j] <- max(table[i,j] - confidencev * table_se[i,j],0)
      }
    }
  }
  rownames(output) <-  rownames(table)
  colnames(output) <-  colnames(table)
    return(output)
}


#n_nested = 10

AUC_m_1_with_microbiome_train <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
AUC_m_1_with_microbiome_test <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))

#seAUC_m_1_with_microbiome <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))

cox_coef_list_train = list()
#coef_list = list()
set.seed(1986)

for (x_count in 1:length(day_beginv)) {
  begin_time = day_beginv[x_count]
  day_end = begin_time + day_endv
  
  # remove those that have T1D before landmark time
  all_prediction_metadata_yearx = get_landmark_db(subject_metadata_ordered,begin_time)
  
  # get autoantibodies, family hist, and GRS2 at landmark time
  young_enough = sample_metadata_ordered$age_at_collection <= begin_time
  # get metadata below landmark time and for those that do not have T1D before landmark time
  wont_get_t1D_before_landmark = sample_metadata_ordered$m138_maskid%in%rownames(all_prediction_metadata_yearx)
  
  metadata_temp = sample_metadata_ordered[young_enough & wont_get_t1D_before_landmark,]
  # get abundance samples below landmark time
  abundance_data_temp = microbiome_abundances_intersection[,metadata_temp$Run]
  # now get autoantibodies per subject
  num_autoantibodies_per_subj = sapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    oldest_samp = unlist(df_temp[which.max(as.numeric(df_temp$age_at_collection)),])
    oldest_age = as.numeric(oldest_samp["age_at_collection"])
    had_MIAA <- oldest_age >= as.numeric(oldest_samp["age_first_MIAA"])
    if(is.na(had_MIAA)) {
      had_MIAA = FALSE
    }
    had_GAD <- oldest_age >= as.numeric(oldest_samp["age_first_GAD"])
    if(is.na(had_GAD)) {
      had_GAD = FALSE
    }
    had_IA2A <- oldest_age >= as.numeric(oldest_samp["age_first_IA2A"])
    if(is.na(had_IA2A)) {
      had_IA2A = FALSE
    }
    num_autoantibodies_had = sum(as.numeric(c(had_MIAA,had_GAD,had_IA2A)))
    return(num_autoantibodies_had)
  })
  
  # get the average abundance of microbiome gene for each subject before landmark time
  abundance_data_temp_subject = lapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    runs_temp = df_temp$Run
    return(rowMeans(abundance_data_temp[,runs_temp,drop=FALSE]))
  })
  abundance_data_temp_subject_df = do.call("rbind",abundance_data_temp_subject)
  abundance_data_temp_subject_df = apply(abundance_data_temp_subject_df, 2, function(x) RankNorm(x))
  
  # add antibody number to metadata
  all_prediction_metadata_yearx$num_autoantibodies = num_autoantibodies_per_subj[match(rownames(all_prediction_metadata_yearx),names(num_autoantibodies_per_subj))]
  # NA antibodies are 0
  all_prediction_metadata_yearx$num_autoantibodies[is.na(all_prediction_metadata_yearx$num_autoantibodies)] = 0
  # make fdr and autoantibodies factors
  if(length(unique(all_prediction_metadata_yearx$fdr)) >1) {
    all_prediction_metadata_yearx$fdr = as.factor(all_prediction_metadata_yearx$fdr)
  }
  if(length(unique(all_prediction_metadata_yearx$num_autoantibodies)) >1) {
    all_prediction_metadata_yearx$num_autoantibodies = as.factor(all_prediction_metadata_yearx$num_autoantibodies)
  }
  
  # now add microbiome data
  abundance_data_temp_subject_df = abundance_data_temp_subject_df[match(rownames(all_prediction_metadata_yearx),rownames(abundance_data_temp_subject_df)),]
  # any NAs are because we don't have samples at landmark time 
  all_prediction_metadata_yearx_withMicrobiome = cbind(all_prediction_metadata_yearx,abundance_data_temp_subject_df)
  # remove samples where I don't have microbiome data for it
  all_prediction_metadata_yearx_withMicrobiome = all_prediction_metadata_yearx_withMicrobiome[!is.na(all_prediction_metadata_yearx_withMicrobiome[,6]),]
  # what if instead of removing samples I say value is 0 
  #all_prediction_metadata_yearx_withMicrobiome[is.na(all_prediction_metadata_yearx_withMicrobiome)] = 0
  
  # now split into train and test sets
  
    train_subjects = read.table("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.train_subjects.txt")
  train_subjects = train_subjects[,1]
  test_subjects = read.table("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.test_subjects.txt")
  test_subjects = test_subjects[,1]

  train_subjects_to_keep = intersect(train_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  test_subects_to_keep = intersect(test_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  
  all_prediction_metadata_yearx_withMicrobiome_train = all_prediction_metadata_yearx_withMicrobiome[train_subjects_to_keep,]
  all_prediction_metadata_yearx_withMicrobiome_test = all_prediction_metadata_yearx_withMicrobiome[test_subects_to_keep,]

  
  variables_for_prediction = c("fdr","num_autoantibodies","grs2")
  
  ## do stepwise selection to choose important microbiome genes. 
    variables_for_prediction_plus_microbiome = c(variables_for_prediction,colnames(abundance_data_temp_subject_df))
  #model_train_min <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  #model_train_max <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))

    
  my_formula1_max_vars <- paste0("~",paste(variables_for_prediction_plus_microbiome, collapse = " + "))
  my_formula_2_min_vars <- paste0("~",paste(variables_for_prediction, collapse = " + "))
  my_formula1_max_vars<- as.formula(paste("Surv(time,getsT1D)",my_formula1_max_vars,sep=""))
  my_formula_2_min_vars<- as.formula(paste("Surv(time,getsT1D)",my_formula_2_min_vars,sep=""))
  
  model_train_min <- coxph(my_formula_2_min_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  model_train_max <- coxph(my_formula1_max_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  
  coefs = tryCatch({
  my_solution = step(model_train_min,scope = list(upper=formula(model_train_max),lower=formula(model_train_min)), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
  coefs = summary(my_solution)$coefficients
},error = function(e) {
        coefs = summary(model_train_min)$coefficients
        return(coefs)
})
  
  #my_solution = step(model_train_min,scope = list(upper=formula(model_train_max),lower=formula(model_train_min)), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
  
  #coefs = summary(my_solution)$coefficients
  #coef_list[[x_count]] = coefs
  
  metadata_coef_pos = unlist(sapply(c("fdr","num_autoantibodies","grs2"), function(var) grep(var,rownames(coefs))))
  
  microbiome_coefs = coefs[-metadata_coef_pos,,drop=FALSE]
  microbiome_coefs = rownames(microbiome_coefs)
  
  # now that I have my variables do predictions
  
  variables_for_prediction_with_microbiome = c(variables_for_prediction,microbiome_coefs)
  
  my_formula <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction_with_microbiome, collapse = " + ")))
  
  
  res.cox_train <- coxph(my_formula, data = all_prediction_metadata_yearx_withMicrobiome_train)
  
  cox_coef_list_train[[x_count]] = res.cox_train$coef
  
  # extract linear predition in the log hazard function
  marker_score_train <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_train, type = "risk")
  marker_score_test <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_test, type = "risk")
  delta_train <- all_prediction_metadata_yearx_withMicrobiome_train[["getsT1D"]]
  delta_test <- all_prediction_metadata_yearx_withMicrobiome_test[["getsT1D"]]
  ROC.T_train <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_train$time,
              delta = delta_train,marker = marker_score_train,
              cause = 1, weighting = "marginal",
              times = day_end,
              iid = FALSE) # set to false for now
  ROC.T_test <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_test$time,
              delta = delta_test,marker = marker_score_test,
              cause = 1, weighting = "marginal",
              times = day_end,
              iid = FALSE) # set to false for now

  AUC_m_1_with_microbiome_train[x_count,] = ROC.T_train$AUC
  AUC_m_1_with_microbiome_test[x_count,] = ROC.T_test$AUC
}
  # cross validation time
  #avg_auc_mat_nested_with_microbiome = matrix(NA,nrow=n_nested,ncol=length(day_end))
  #seAUC_m_n_nested_with_microbiome = matrix(NA,nrow=n_nested,ncol=length(day_end))
  
  #avg_cox_coefs_mat_nested = matrix(NA,nrow=n_nested,ncol=nrow(coefs))
  #se_cox_coefs_mat_nested = matrix(NA,nrow=n_nested,ncol=nrow(coefs))
  #colnames(avg_cox_coefs_mat_nested) = rownames(coefs)
  #colnames(se_cox_coefs_mat_nested) = rownames(coefs)

  #for (j in 1:n_nested) {
    # randomly shuffle data
  #  dataset_ml <- all_prediction_metadata_yearx_withMicrobiome[sample(nrow(all_prediction_metadata_yearx_withMicrobiome)),]
    #Create k equally size folds
  #  k=3
  #  folds <- cut(seq(1,nrow(dataset_ml)),breaks = k,labels = FALSE)
  #  kfolds_mat = matrix(NA,nrow = k, ncol = length(day_end))
    
  #  kfolds_coxCoef_mat = matrix(NA,nrow=k,ncol=nrow(coefs))
  #  colnames(kfolds_coxCoef_mat) = rownames(coefs)
    
  #  for (i in 1:k) {
  #    testIndexes <- which(folds == i,arr.ind = TRUE)
  #    testData <- dataset_ml[testIndexes, ]
  #    trainData <- dataset_ml[-testIndexes, ]
  #    res.cox <- coxph(my_formula, data = trainData)
  #    kfolds_coxCoef_mat[i,] = res.cox$coef[colnames(kfolds_coxCoef_mat)]
  #    # extract linear predition in the log hazard function
  #    marker_score <- predict(res.cox, testData, type = "risk")
  #    delta <- testData[["getsT1D"]]
  #    ROC.T <- timeROC(T = testData$time,
  #                delta = delta,marker = marker_score,
  #                cause = 1, weighting = "marginal",
  #                times = day_end,
  #                iid = FALSE) # set to false for now
  #    kfolds_mat[i,] = ROC.T$AUC
  #  }
  #  # average the predictions for each part of the data
  #  k_avg_AUC = colMeans(kfolds_mat,na.rm=TRUE)
  #  # average cox regression coefs
  #  k_avg_cox_coefs = colMeans(kfolds_coxCoef_mat,na.rm=TRUE)
  #  # I do this 10 times so add the results
  #  avg_auc_mat_nested_with_microbiome[j,] = k_avg_AUC
  #  avg_cox_coefs_mat_nested[j,] = k_avg_cox_coefs
  #  # standard deviation is the variation within the different parts of the data
  #  seAUC_m_n_nested_with_microbiome[j,] = apply(kfolds_mat,2,function(x) var(x,na.rm=TRUE))
  #  se_cox_coefs_mat_nested[j,] = apply(kfolds_coxCoef_mat,2,function(x) var(x,na.rm=TRUE))
  #}
  # take a final average of our repeats
  #final_avg_auc = colMeans(avg_auc_mat_nested_with_microbiome)
  #AUC_m_1_with_microbiome[x_count,] = final_avg_auc
  #seAUC_m_1_with_microbiome[x_count,] <- apply(seAUC_m_n_nested_with_microbiome,2,function(x) sqrt(mean(x,na.rm = TRUE)))
  # add coefficients and sds to lists
  #cox_coef_list[[x_count]] = colMeans(avg_cox_coefs_mat_nested)
  #cox_sd_list[[x_count]] = apply(se_cox_coefs_mat_nested,2,function(x) sqrt(mean(x,na.rm = TRUE)))
#}
# create confidence intervals with the standard errors
#confup_with_microbiome <- create_IC_se(AUC_m_1_with_microbiome,seAUC_m_1_with_microbiome,confidencev = 1.96, class = "up")
#conflow_with_microbiome <- create_IC_se(AUC_m_1_with_microbiome,seAUC_m_1_with_microbiome,confidencev = 1.96, class = "low")

# calculate up and down confidence interval for cox regression coefficients

create_IC_cox_reg <- function(cox_reg_list,cox_reg_sd_list,confidencev=1.96){
  final_list = list()
  for(y in 1:length(cox_reg_list)) {
    cox_reg_vec = cox_reg_list[[y]]
    cox_reg_sd_vec = cox_reg_sd_list[[y]]
    mydf = matrix(0,nrow=length(cox_reg_vec),ncol=3)
    for(x in 1:length(cox_reg_vec)) {
      coef_temp = cox_reg_vec[x]
      sd_temp = cox_reg_sd_vec[x]
      confup = coef_temp + confidencev * sd_temp
      confdown = coef_temp - confidencev * sd_temp
      final_vec = c(coef=coef_temp,up=confup,down=confdown)
      mydf[x,] = final_vec
    }
    colnames(mydf) = c("coef","up","down")
    rownames(mydf) = names(cox_reg_sd_vec)
    mydf = as.data.frame(mydf)
    mydf = cbind(name=rownames(mydf),mydf)
    final_list[[y]] = mydf
  }
  return(final_list)
}
  
#cox_reg_coef_sd_tables = create_IC_cox_reg(cox_coef_list,cox_sd_list)

```




```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

# function that removes subjects who were censored or had T1D before landmark time
get_landmark_db = function(mydf,day_begin_temp) {
  bool_temp = which(mydf$time < day_begin_temp)
  if(length(bool_temp) >0) {
    newDF = mydf[-bool_temp,]
    return(newDF)
  } else {
    return(mydf)
  }
}

getAUCs = function(sample_metadata,subject_metada,microbe_abundances,day_beginv,day_endv,train_subject_file,test_subject_file,min_vars_to_keep,max_vars_to_keep) {
AUC_m_1_with_microbiome_train <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
AUC_m_1_with_microbiome_test <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))

cox_coef_list_train = list()
#coef_list = list()
set.seed(1986)

for (x_count in 1:length(day_beginv)) {
  print(x_count)
  begin_time = day_beginv[x_count]
  day_end = begin_time + day_endv
  
  # remove those that have T1D before landmark time
  all_prediction_metadata_yearx = get_landmark_db(subject_metada,begin_time)
  
  # get autoantibodies, family hist, and GRS2 at landmark time
  young_enough = sample_metadata$age_at_collection <= begin_time
  # get metadata below landmark time and for those that do not have T1D before landmark time
  wont_get_t1D_before_landmark = sample_metadata$m138_maskid%in%rownames(all_prediction_metadata_yearx)
  
  metadata_temp = sample_metadata[young_enough & wont_get_t1D_before_landmark,]
  # get abundance samples below landmark time
  abundance_data_temp = microbe_abundances[,metadata_temp$Run]
  # now get autoantibodies per subject
  num_autoantibodies_per_subj = sapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    oldest_samp = unlist(df_temp[which.max(as.numeric(df_temp$age_at_collection)),])
    oldest_age = as.numeric(oldest_samp["age_at_collection"])
    had_MIAA <- oldest_age >= as.numeric(oldest_samp["age_first_MIAA"])
    if(is.na(had_MIAA)) {
      had_MIAA = FALSE
    }
    had_GAD <- oldest_age >= as.numeric(oldest_samp["age_first_GAD"])
    if(is.na(had_GAD)) {
      had_GAD = FALSE
    }
    had_IA2A <- oldest_age >= as.numeric(oldest_samp["age_first_IA2A"])
    if(is.na(had_IA2A)) {
      had_IA2A = FALSE
    }
    num_autoantibodies_had = sum(as.numeric(c(had_MIAA,had_GAD,had_IA2A)))
    return(num_autoantibodies_had)
  })
  
  # get the average abundance of microbiome gene for each subject before landmark time
  abundance_data_temp_subject = lapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    runs_temp = df_temp$Run
    return(rowMeans(abundance_data_temp[,runs_temp,drop=FALSE]))
  })
  abundance_data_temp_subject_df = do.call("rbind",abundance_data_temp_subject)
  abundance_data_temp_subject_df = apply(abundance_data_temp_subject_df, 2, function(x) RankNorm(x))
  
  # add antibody number to metadata
  all_prediction_metadata_yearx$num_autoantibodies = num_autoantibodies_per_subj[match(rownames(all_prediction_metadata_yearx),names(num_autoantibodies_per_subj))]
  # NA antibodies are 0
  all_prediction_metadata_yearx$num_autoantibodies[is.na(all_prediction_metadata_yearx$num_autoantibodies)] = 0
  # make fdr and autoantibodies factors
  if(length(unique(all_prediction_metadata_yearx$fdr)) >1) {
    all_prediction_metadata_yearx$fdr = as.factor(all_prediction_metadata_yearx$fdr)
  }
  if(length(unique(all_prediction_metadata_yearx$num_autoantibodies)) >1) {
    all_prediction_metadata_yearx$num_autoantibodies = as.factor(all_prediction_metadata_yearx$num_autoantibodies)
  }
  
  # now add microbiome data
  abundance_data_temp_subject_df = abundance_data_temp_subject_df[match(rownames(all_prediction_metadata_yearx),rownames(abundance_data_temp_subject_df)),]
  # any NAs are because we don't have samples at landmark time 
  all_prediction_metadata_yearx_withMicrobiome = cbind(all_prediction_metadata_yearx,abundance_data_temp_subject_df)
  # remove samples where I don't have microbiome data for it
  all_prediction_metadata_yearx_withMicrobiome = all_prediction_metadata_yearx_withMicrobiome[!is.na(all_prediction_metadata_yearx_withMicrobiome[,6]),]
  # what if instead of removing samples I say value is 0 
  #all_prediction_metadata_yearx_withMicrobiome[is.na(all_prediction_metadata_yearx_withMicrobiome)] = 0
  
  # now split into train and test sets
  
  train_subjects = read.table(train_subject_file)
  train_subjects = train_subjects[,1]
  test_subjects = read.table(test_subject_file)
  test_subjects = test_subjects[,1]

  train_subjects_to_keep = intersect(train_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  test_subects_to_keep = intersect(test_subjects,rownames(all_prediction_metadata_yearx_withMicrobiome))
  
  all_prediction_metadata_yearx_withMicrobiome_train = all_prediction_metadata_yearx_withMicrobiome[train_subjects_to_keep,]
  all_prediction_metadata_yearx_withMicrobiome_test = all_prediction_metadata_yearx_withMicrobiome[test_subects_to_keep,]

  
  #variables_for_prediction = c("fdr","num_autoantibodies","grs2") min_vars_to_keep max_vars_to_keep
  
  ## do stepwise selection to choose important microbiome genes. 
    #variables_for_prediction_plus_microbiome = c(variables_for_prediction,colnames(abundance_data_temp_subject_df))
  #model_train_min <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  #model_train_max <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))

    
  my_formula1_max_vars <- paste0("~",paste(max_vars_to_keep, collapse = " + "))
  my_formula_2_min_vars <- paste0("~",paste(min_vars_to_keep, collapse = " + "))
  my_formula1_max_vars<- as.formula(paste("Surv(time,getsT1D)",my_formula1_max_vars,sep=""))
  my_formula_2_min_vars<- as.formula(paste("Surv(time,getsT1D)",my_formula_2_min_vars,sep=""))
  
  model_train_min <- coxph(my_formula_2_min_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  #model_train_max <- coxph(my_formula1_max_vars,data=all_prediction_metadata_yearx_withMicrobiome_train,control = coxph.control(iter.max = 50))
  
  res.cox_train = tryCatch({
  res.cox_train = step(model_train_min,scope = list(upper=my_formula1_max_vars,lower=my_formula_2_min_vars), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
},error = function(e) {
        #coefs = summary(model_train_min)$coefficients
        res.cox_train = step(model_train_min,scope = list(upper=formula(model_train_min),lower=formula(model_train_min)), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
        return(res.cox_train)
})
  
  #my_solution = step(model_train_min,scope = list(upper=formula(model_train_max),lower=formula(model_train_min)), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
  
  coefs = summary(res.cox_train)$coefficients
  #coef_list[[x_count]] = coefs
  
  #metadata_coef_pos = unlist(sapply(c("fdr","num_autoantibodies","grs2"), function(var) grep(var,rownames(coefs))))
  
  #microbiome_coefs = coefs[-metadata_coef_pos,,drop=FALSE]
  
  microbiome_coefs = coefs[coefs%in%rownames(microbe_abundances)]
  
  microbiome_coefs = rownames(microbiome_coefs)
  
  # now that I have my variables do predictions
  
  #variables_for_prediction_with_microbiome = rownames(coefs)
  
  #my_formula <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction_with_microbiome, collapse = " + ")))
  
  
  #res.cox_train <- coxph(my_formula, data = all_prediction_metadata_yearx_withMicrobiome_train)
  
  cox_coef_list_train[[x_count]] = res.cox_train$coef
  
  # extract linear predition in the log hazard function
  marker_score_train <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_train, type = "risk")
  marker_score_test <- predict(res.cox_train, all_prediction_metadata_yearx_withMicrobiome_test, type = "risk")
  delta_train <- all_prediction_metadata_yearx_withMicrobiome_train[["getsT1D"]]
  delta_test <- all_prediction_metadata_yearx_withMicrobiome_test[["getsT1D"]]
  ROC.T_train <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_train$time,
              delta = delta_train,marker = marker_score_train,
              cause = 1, weighting = "marginal",
              times = day_end,
              iid = FALSE) # set to false for now
  ROC.T_test <- timeROC(T = all_prediction_metadata_yearx_withMicrobiome_test$time,
              delta = delta_test,marker = marker_score_test,
              cause = 1, weighting = "marginal",
              times = day_end,
              iid = FALSE) # set to false for now

  AUC_m_1_with_microbiome_train[x_count,] = ROC.T_train$AUC
  AUC_m_1_with_microbiome_test[x_count,] = ROC.T_test$AUC
}
  return(list(AUC_m_1_with_microbiome_train,AUC_m_1_with_microbiome_test))
}


min_vars_to_keep = c("fdr","num_autoantibodies","grs2")
max_vars_to_keep = c("fdr","num_autoantibodies","grs2",rownames(microbiome_abundances_intersection))

clincal_and_microbe_AUCs = getAUCs(sample_metadata_ordered, subject_metadata_ordered,microbiome_abundances_intersection,day_beginv,day_endv,"~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.train_subjects.txt","~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.test_subjects.txt",min_vars_to_keep,max_vars_to_keep)

clincal_AUCs = getAUCs(sample_metadata_ordered, subject_metadata_ordered,microbiome_abundances_intersection,day_beginv,day_endv,"~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.train_subjects.txt","~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.test_subjects.txt",min_vars_to_keep,min_vars_to_keep)

microbe_AUCs = getAUCs(sample_metadata=sample_metadata_ordered, subject_metada = subject_metadata_ordered,microbe_abundances = microbiome_abundances_intersection,day_beginv,day_endv,train_subject_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.train_subjects.txt",test_subject_file="~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/TEDDY_analysis_v2_march_2022/processed_teddy_metadata_for_regression_march9_2022/healthy_pre-t1d-all_HLA.test_subjects.txt",min_vars_to_keep=c(1),max_vars_to_keep=rownames(microbiome_abundances_intersection))

```

#Make plots

```{r}
library(cowplot)
make_plots = function(prediction_auc_list) {
  train_aucs = prediction_auc_list[[1]]
  test_aucs = prediction_auc_list[[2]]
  prediction_at = c(0.25,0.6,1,1.5,2,2.5,3)
  prediction_for <- c(1,3,5,8)
  rownames(train_aucs) = prediction_at
  rownames(test_aucs) = prediction_at
  colnames(train_aucs) = prediction_for
  colnames(test_aucs) = prediction_for
  
  test_aucs_melt = reshape2::melt(test_aucs)
  train_aucs_melt = reshape2::melt(train_aucs)
  colnames(test_aucs_melt) = c("Landscape","Horizon","AUC")
  colnames(train_aucs_melt) = c("Landscape","Horizon","AUC")
  train_aucs_melt$type = "train"
  test_aucs_melt$type = "test"
  train_aucs_melt$Horizon = as.factor(train_aucs_melt$Horizon)
  test_aucs_melt$Horizon = as.factor(train_aucs_melt$Horizon)
  aucs_df = rbind(train_aucs_melt,test_aucs_melt)
  aucs_df$type = as.factor(aucs_df$type)
  plotA = ggplot(train_aucs_melt,aes(x=Landscape,y=AUC,group=Horizon)) + geom_line(aes(color=Horizon)) + geom_point(aes(color=Horizon)) + theme_bw() + ylim(0,1)
  plotB = ggplot(test_aucs_melt,aes(x=Landscape,y=AUC,group=Horizon)) + geom_line(aes(color=Horizon)) + geom_point(aes(color=Horizon)) + theme_bw() + ylim(0,1)
  myplots = plot_grid(plotA, plotB, labels = c("train","test"))
  return(myplots)
}

clincal_and_microbe_AUCs_plots = make_plots(clincal_and_microbe_AUCs)
pdf("clincal_and_microbe_AUCs_plots.pdf")
print(clincal_and_microbe_AUCs_plots)
dev.off()
clincal_AUCs_plots = make_plots(clincal_AUCs)
pdf("clincal_AUCs_plots.pdf")
print(clincal_AUCs_plots)
dev.off()
pdf("microbe_AUCs_plots.pdf")
microbe_AUCs_plots = make_plots(microbe_AUCs)
print(microbe_AUCs_plots)
dev.off()
```







#Predictions with just FDR,autoantibodies, and GRS2 score

```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

# function that removes subjects who were censored or had T1D before landmark time
get_landmark_db = function(mydf,day_begin_temp) {
  bool_temp = which(mydf$time < day_begin_temp)
  if(length(bool_temp) >0) {
    newDF = mydf[-bool_temp,]
    return(newDF)
  } else {
    return(mydf)
  }
}

create_IC_se <- function(table,table_se,confidencev=1.96, class){
  n1 <- dim(table)[1]
  n2 <- dim(table)[2]
  output <- matrix(NA, nrow = n1, ncol = n2)
  for (i in 1:n1) {
    for (j in 1:n2) {
      if (class == "up") {
        output[i,j] <- min(table[i,j] + confidencev * table_se[i,j],1)
      }
      else{
        output[i,j] <- max(table[i,j] - confidencev * table_se[i,j],0)
      }
    }
  }
  rownames(output) <-  rownames(table)
  colnames(output) <-  colnames(table)
    return(output)
}


#n_nested = 10

AUC_m_1_train <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
AUC_m_1_test <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
#seAUC_m_1 <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
set.seed(1986)

for (x_count in 1:length(day_beginv)) {
  begin_time = day_beginv[x_count]
  day_end = begin_time + day_endv
  
  # remove those that have T1D before landmark time
  all_prediction_metadata_yearx = get_landmark_db(subject_metadata_ordered,begin_time)
  
  # get autoantibodies, family hist, and GRS2 at landmark time
  young_enough = sample_metadata_ordered$age_at_collection <= begin_time
  # get metadata below landmark time and for those that do not have T1D before landmark time
  wont_get_t1D_before_landmark = sample_metadata_ordered$m138_maskid%in%rownames(all_prediction_metadata_yearx)
  
  metadata_temp = sample_metadata_ordered[young_enough & wont_get_t1D_before_landmark,]

  # now get autoantibodies per subject
  num_autoantibodies_per_subj = sapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    oldest_samp = unlist(df_temp[which.max(as.numeric(df_temp$age_at_collection)),])
    oldest_age = as.numeric(oldest_samp["age_at_collection"])
    had_MIAA <- oldest_age >= as.numeric(oldest_samp["age_first_MIAA"])
    if(is.na(had_MIAA)) {
      had_MIAA = FALSE
    }
    had_GAD <- oldest_age >= as.numeric(oldest_samp["age_first_GAD"])
    if(is.na(had_GAD)) {
      had_GAD = FALSE
    }
    had_IA2A <- oldest_age >= as.numeric(oldest_samp["age_first_IA2A"])
    if(is.na(had_IA2A)) {
      had_IA2A = FALSE
    }
    num_autoantibodies_had = sum(as.numeric(c(had_MIAA,had_GAD,had_IA2A)))
    return(num_autoantibodies_had)
  })
  
  # add antibody number to metadata
  all_prediction_metadata_yearx$num_autoantibodies = num_autoantibodies_per_subj[match(rownames(all_prediction_metadata_yearx),names(num_autoantibodies_per_subj))]
  # NA antibodies are 0
  all_prediction_metadata_yearx$num_autoantibodies[is.na(all_prediction_metadata_yearx$num_autoantibodies)] = 0
  # make fdr and autoantibodies factors
  if(length(unique(all_prediction_metadata_yearx$fdr)) >1) {
    all_prediction_metadata_yearx$fdr = as.factor(all_prediction_metadata_yearx$fdr)
  }
  if(length(unique(all_prediction_metadata_yearx$num_autoantibodies)) >1) {
    all_prediction_metadata_yearx$num_autoantibodies = as.factor(all_prediction_metadata_yearx$num_autoantibodies)
  }
  
  variables_for_prediction = c("fdr","num_autoantibodies","grs2")
  
  my_formula <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction, collapse = " + ")))
  # cross validation time
  avg_auc_mat_nested = matrix(NA,nrow=n_nested,ncol=length(day_end))
  seAUC_m_n_nested = matrix(NA,nrow=n_nested,ncol=length(day_end))
  for (j in 1:n_nested) {
    # randomly shuffle data
    dataset_ml <- all_prediction_metadata_yearx[sample(nrow(all_prediction_metadata_yearx)),]
    #Create k equally size folds
    k=3
    folds <- cut(seq(1,nrow(dataset_ml)),breaks = k,labels = FALSE)
    kfolds_mat = matrix(NA,nrow = k, ncol = length(day_end))
    for (i in 1:k) {
      testIndexes <- which(folds == i,arr.ind = TRUE)
      testData <- dataset_ml[testIndexes, ]
      trainData <- dataset_ml[-testIndexes, ]
      res.cox <- coxph(my_formula, data = trainData)
      # extract linear predition in the log hazard function
      marker_score <- predict(res.cox, testData, type = "risk")
      delta <- testData[["getsT1D"]]
      ROC.T <- timeROC(T = testData$time,
                  delta = delta,marker = marker_score,
                  cause = 1, weighting = "marginal",
                  times = day_end,
                  iid = FALSE) # set to false for now
      kfolds_mat[i,] = ROC.T$AUC
    }
    # average the predictions for each part of the data
    k_avg_AUC = colMeans(kfolds_mat,na.rm=TRUE)
    # I do this 10 times so add the results
    avg_auc_mat_nested[j,] = k_avg_AUC
    # standard deviation is the variation within the different parts of the data
    seAUC_m_n_nested[j,] = apply(kfolds_mat,2,function(x) var(x,na.rm=TRUE))
  }
  # take a final average of our repeats
  final_avg_auc = colMeans(avg_auc_mat_nested)
  AUC_m_1[x_count,] = final_avg_auc
  seAUC_m_1[x_count,] <- apply(seAUC_m_n_nested,2,function(x) sqrt(mean(x,na.rm = TRUE)))
}
# create confidence intervals with the standard errors
confup <- create_IC_se(AUC_m_1,seAUC_m_1,confidencev = 1.96, class = "up")
conflow <- create_IC_se(AUC_m_1,seAUC_m_1,confidencev = 1.96, class = "low")

```

#Make AUC plot with microbiome data and standard metadata alone

```{r}
library(dplyr)
library(tidyr)
library(cowplot)
library(reshape2)

prediction_at = c(0.25,0.6,1,1.5,2,2.5,3)
prediction_for <- c(1,3,5,8)

# set rownames and columnames to the landmark and horizon times
rownames(AUC_m_1) <- prediction_at 
colnames(AUC_m_1) <- prediction_for
rownames(conflow) <- prediction_at 
colnames(conflow) <- prediction_for
rownames(confup) <- prediction_at 
colnames(confup) <- prediction_for

rownames(AUC_m_1_with_microbiome) <- prediction_at 
colnames(AUC_m_1_with_microbiome) <- prediction_for
rownames(conflow_with_microbiome) <- prediction_at 
colnames(conflow_with_microbiome) <- prediction_for
rownames(confup_with_microbiome) <- prediction_at 
colnames(confup_with_microbiome) <- prediction_for

# put data in wide ggplot format
AUC_m_1_melt = melt(AUC_m_1)
colnames(AUC_m_1_melt) = c("time_from","time_to","AUC")
conflow_melt = melt(conflow)
colnames(conflow_melt) = c("time_from","time_to","low")
confup_melt = melt(confup)
colnames(confup_melt) = c("time_from","time_to","up")

AUC_m_1_with_microbiome_melt = melt(AUC_m_1_with_microbiome)
colnames(AUC_m_1_with_microbiome_melt) = c("time_from","time_to","AUC")
conflow_with_microbiome_melt = melt(conflow_with_microbiome)
colnames(conflow_with_microbiome_melt) = c("time_from","time_to","low")
confup_with_microbiome_melt = melt(confup_with_microbiome)
colnames(confup_with_microbiome_melt) = c("time_from","time_to","up")

# merge the data frames together
AUC_m_1_with_microbiome_melt = merge(AUC_m_1_with_microbiome_melt,conflow_with_microbiome_melt,by=c("time_from","time_to"))
AUC_m_1_with_microbiome_melt = merge(AUC_m_1_with_microbiome_melt,confup_with_microbiome_melt,by=c("time_from","time_to"))
AUC_m_1_with_microbiome_melt$time_to = as.factor(AUC_m_1_with_microbiome_melt$time_to)

AUC_m_1_with_microbiome_melt$predictors = "Microbiome+AA+FDR+GRS"

AUC_m_1_melt = merge(AUC_m_1_melt,conflow_melt,by=c("time_from","time_to"))
AUC_m_1_melt = merge(AUC_m_1_melt,confup_melt,by=c("time_from","time_to"))
AUC_m_1_melt$time_to = as.factor(AUC_m_1_melt$time_to)

# now bind the microbiome plus other data and the other data alone together

AUC_m_1_melt$predictors = "AA+FDR+GRS"
AUC_m_1_melt$predictors = as.factor(AUC_m_1_melt$predictors)
AUC_m_1_melt_all = rbind(AUC_m_1_melt,AUC_m_1_with_microbiome_melt)
AUC_m_1_melt_all$predictors = as.factor(AUC_m_1_melt_all$predictors)

pdf("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/AUC_comparison_plot.pdf",width=10)
ggplot(AUC_m_1_melt_all, aes(x=time_from,y=AUC)) + geom_point(aes(colour = time_to, shape = time_to),size = 5) + geom_line(aes(colour = time_to,linetype=predictors),size = 0.5) + geom_ribbon(data = AUC_m_1_with_microbiome_melt,aes(ymin = low,ymax = up,fill = time_to),alpha = 0.1,show.legend = FALSE, colour = "transparent") + theme_bw() + scale_y_continuous(breaks = seq(0,1,0.1),limits = c(0,1)) + labs(x="",y="") + theme(legend.title=element_text(size=20),legend.text = element_text(size=20))
dev.off()


### now lets make a rainforest plot to show how the microbiome importance compares to other factors

#library(metaviz)

#names(coef_list) = prediction_at

#pdf("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/forestPlots.pdf")
#for(x in 1:length(coef_list[-1])) {
#  coefs_temp = coef_list[-1][[x]]
#  coefs_temp = coefs_temp[,c(1,3)]
#  coefs_temp = coefs_temp[order(abs(coefs_temp[,1]),decreasing=TRUE),]
#  myplot = viz_forest(x=coefs_temp,study_labels=rownames(coefs_temp),xlab="log risk ratio") + ggtitle(paste(names(coef_list[-1][x]),"year"))
#  print(myplot)
#}
#dev.off()

names(cox_reg_coef_sd_tables) = prediction_at

for(x in 1:length(cox_reg_coef_sd_tables)) {
  coefs_temp = cox_reg_coef_sd_tables[[x]]
  myplot = ggplot(coefs_temp, aes(x = reorder(name,abs(coef)), y = coef)) + geom_point(size = 2) + geom_errorbar(aes(ymin = down, ymax = up)) + coord_flip() + ggtitle(paste(names(cox_reg_coef_sd_tables[x]),"year")) + geom_hline(aes(yintercept = 0,color="red")) + ylab("mean log risk ratio") + xlab("feature")
  jpeg(paste("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/forest_plots/",names(cox_reg_coef_sd_tables[x])," year",sep=""))
  print(myplot)
  dev.off()
}
```

#Get difference between the 2


```{r}
day_beginv = c(92, 183, 365, 548, 730,912,1095)
# times we will predict on. e.g. if landmark is 105 days, and day_end is 365.25 then we predict T1D status at 470.25 days
day_endv <- c(365.25,365.25*3,5*365.25,8*365.25)

# function that removes subjects who were censored or had T1D before landmark time
get_landmark_db = function(mydf,day_begin_temp) {
  bool_temp = which(mydf$time < day_begin_temp)
  if(length(bool_temp) >0) {
    newDF = mydf[-bool_temp,]
    return(newDF)
  } else {
    return(mydf)
  }
}

create_IC_se_diff <- function(table,table_se,confidencev=1.96, class){
  n1 <- dim(table)[1]
  n2 <- dim(table)[2]
  output <- matrix(NA, nrow = n1, ncol = n2)
  for (i in 1:n1) {
    for (j in 1:n2) {
      if (class == "up") {
        output[i,j] <- table[i,j] + confidencev * table_se[i,j]
      }
      else{
        output[i,j] <- table[i,j] - confidencev * table_se[i,j]
      }
    }
  }
  rownames(output) <-  rownames(table)
  colnames(output) <-  colnames(table)
    return(output)
}


n_nested = 10

AUC_diff <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))
seAUC_diff <- matrix(NA, nrow = length(day_beginv), ncol = length(day_endv))

set.seed(1986)

for (x_count in 1:length(day_beginv)) {
  begin_time = day_beginv[x_count]
  day_end = begin_time + day_endv
  
  # remove those that have T1D before landmark time
  all_prediction_metadata_yearx = get_landmark_db(subject_metadata_ordered,begin_time)
  
  # get autoantibodies, family hist, and GRS2 at landmark time
  young_enough = sample_metadata_ordered$age_at_collection <= begin_time
  # get metadata below landmark time and for those that do not have T1D before landmark time
  wont_get_t1D_before_landmark = sample_metadata_ordered$m138_maskid%in%rownames(all_prediction_metadata_yearx)
  
  metadata_temp = sample_metadata_ordered[young_enough & wont_get_t1D_before_landmark,]
  # get abundance samples below landmark time
  abundance_data_temp = microbiome_abundances_log_intersection[,metadata_temp$Run]
  # now get autoantibodies per subject
  num_autoantibodies_per_subj = sapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    oldest_samp = unlist(df_temp[which.max(as.numeric(df_temp$age_at_collection)),])
    oldest_age = as.numeric(oldest_samp["age_at_collection"])
    had_MIAA <- oldest_age >= as.numeric(oldest_samp["age_first_MIAA"])
    if(is.na(had_MIAA)) {
      had_MIAA = FALSE
    }
    had_GAD <- oldest_age >= as.numeric(oldest_samp["age_first_GAD"])
    if(is.na(had_GAD)) {
      had_GAD = FALSE
    }
    had_IA2A <- oldest_age >= as.numeric(oldest_samp["age_first_IA2A"])
    if(is.na(had_IA2A)) {
      had_IA2A = FALSE
    }
    num_autoantibodies_had = sum(as.numeric(c(had_MIAA,had_GAD,had_IA2A)))
    return(num_autoantibodies_had)
  })
  
  # get the average abundance of microbiome gene for each subject before landmark time
  abundance_data_temp_subject = lapply(split(metadata_temp,metadata_temp$m138_maskid), function(df_temp) {
    runs_temp = df_temp$Run
    return(rowMeans(abundance_data_temp[,runs_temp,drop=FALSE]))
  })
  abundance_data_temp_subject_df = do.call("rbind",abundance_data_temp_subject)
  
  # add antibody number to metadata
  all_prediction_metadata_yearx$num_autoantibodies = num_autoantibodies_per_subj[match(rownames(all_prediction_metadata_yearx),names(num_autoantibodies_per_subj))]
  # NA antibodies are 0
  all_prediction_metadata_yearx$num_autoantibodies[is.na(all_prediction_metadata_yearx$num_autoantibodies)] = 0
  # make fdr and autoantibodies factors
  if(length(unique(all_prediction_metadata_yearx$fdr)) >1) {
    all_prediction_metadata_yearx$fdr = as.factor(all_prediction_metadata_yearx$fdr)
  }
  if(length(unique(all_prediction_metadata_yearx$num_autoantibodies)) >1) {
    all_prediction_metadata_yearx$num_autoantibodies = as.factor(all_prediction_metadata_yearx$num_autoantibodies)
  }
  
  # now add microbiome data
  abundance_data_temp_subject_df = abundance_data_temp_subject_df[match(rownames(all_prediction_metadata_yearx),rownames(abundance_data_temp_subject_df)),]
  # any NAs are because we don't have samples at landmark time 
  all_prediction_metadata_yearx_withMicrobiome = cbind(all_prediction_metadata_yearx,abundance_data_temp_subject_df)
  # remove samples where I don't have microbiome data for it
  all_prediction_metadata_yearx_withMicrobiome = all_prediction_metadata_yearx_withMicrobiome[!is.na(all_prediction_metadata_yearx_withMicrobiome[,6]),]
  # what if instead of removing samples I say value is 0 
  #all_prediction_metadata_yearx_withMicrobiome[is.na(all_prediction_metadata_yearx_withMicrobiome)] = 0
  
  variables_for_prediction = c("fdr","num_autoantibodies","grs2")
  
  ## do stepwise selection to choose important microbiome genes. 61 genes is too many.
    variables_for_prediction_plus_microbiome = c(variables_for_prediction,colnames(abundance_data_temp_subject_df))
  model <- coxph(Surv(time,getsT1D)~ fdr + num_autoantibodies + grs2 ,data = all_prediction_metadata_yearx_withMicrobiome,control = coxph.control(iter.max = 50))
  
  my_formula1 <- as.formula(paste0("~",paste(variables_for_prediction_plus_microbiome, collapse = " + ")))
  
  my_formula_2 <- as.formula(paste0("~",paste(variables_for_prediction, collapse = " + ")))

  my_solution = step(model,scope = list(upper=my_formula1,lower=my_formula_2), direction = "forward", k = log(dim(all_prediction_metadata_yearx_withMicrobiome)[1]),steps = 5000)
  coefs = summary(my_solution)$coefficients
  #coef_list[[x_count]] = coefs
  
  metadata_coef_pos = unlist(sapply(c("fdr","num_autoantibodies","grs2"), function(var) grep(var,rownames(coefs))))
  
  microbiome_coefs = coefs[-metadata_coef_pos,,drop=FALSE]
  microbiome_coefs = rownames(microbiome_coefs)
  
  # now that I have my variables do predictions
  
  variables_for_prediction_with_microbiome = c(variables_for_prediction,microbiome_coefs)
  
  my_formula <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction_with_microbiome, collapse = " + ")))
  my_formula_no_microbiome <- as.formula(paste0("Surv(time, getsT1D)","~",paste(variables_for_prediction, collapse = " + ")))

  # cross validation time
  avg_auc_diff_mat_nested_with_microbiome = matrix(NA,nrow=n_nested,ncol=length(day_end))
  seAUC_m_n_dff_nested_with_microbiome = matrix(NA,nrow=n_nested,ncol=length(day_end))
  
  #avg_cox_coefs_mat_nested = matrix(NA,nrow=n_nested,ncol=nrow(coefs))
  #se_cox_coefs_mat_nested = matrix(NA,nrow=n_nested,ncol=nrow(coefs))
  #colnames(avg_cox_coefs_mat_nested) = rownames(coefs)
  #colnames(se_cox_coefs_mat_nested) = rownames(coefs)

  for (j in 1:n_nested) {
    # randomly shuffle data
    dataset_ml <- all_prediction_metadata_yearx_withMicrobiome[sample(nrow(all_prediction_metadata_yearx_withMicrobiome)),]
    #Create k equally size folds
    k=3
    folds <- cut(seq(1,nrow(dataset_ml)),breaks = k,labels = FALSE)
    kfolds_mat_dff = matrix(NA,nrow = k, ncol = length(day_end))
    
    #kfolds_coxCoef_mat = matrix(NA,nrow=k,ncol=nrow(coefs))
    #colnames(kfolds_coxCoef_mat) = rownames(coefs)
    
    for (i in 1:k) {
      testIndexes <- which(folds == i,arr.ind = TRUE)
      testData <- dataset_ml[testIndexes, ]
      trainData <- dataset_ml[-testIndexes, ]
      res.cox <- coxph(my_formula, data = trainData)
      res.cox_nomicrobiome <- coxph(my_formula_no_microbiome, data = trainData)
      #kfolds_coxCoef_mat[i,] = res.cox$coef[colnames(kfolds_coxCoef_mat)]
      # extract linear predition in the log hazard function
      marker_score <- predict(res.cox, testData, type = "risk")
      marker_score_nomicrobiome <- predict(res.cox_nomicrobiome, testData, type = "risk")
      delta <- testData[["getsT1D"]]
      ROC.T <- timeROC(T = testData$time,
                  delta = delta,marker = marker_score,
                  cause = 1, weighting = "marginal",
                  times = day_end,
                  iid = FALSE) # set to false for now
      ROC.T_nomicrobiome <- timeROC(T = testData$time,
                  delta = delta,marker = marker_score_nomicrobiome,
                  cause = 1, weighting = "marginal",
                  times = day_end,
                  iid = FALSE) # set to false for now

      kfolds_mat_dff[i,] = ROC.T$AUC - ROC.T_nomicrobiome$AUC
    }
    # average the predictions for each part of the data
    k_avg_AUC = colMeans(kfolds_mat_dff,na.rm=TRUE)
    # average cox regression coefs
    #k_avg_cox_coefs = colMeans(kfolds_coxCoef_mat,na.rm=TRUE)
    # I do this 10 times so add the results
    avg_auc_diff_mat_nested_with_microbiome[j,] = k_avg_AUC
    #avg_cox_coefs_mat_nested[j,] = k_avg_cox_coefs
    # standard deviation is the variation within the different parts of the data
    seAUC_m_n_dff_nested_with_microbiome[j,] = apply(kfolds_mat_dff,2,function(x) var(x,na.rm=TRUE))
    #se_cox_coefs_mat_nested[j,] = apply(kfolds_coxCoef_mat,2,function(x) var(x,na.rm=TRUE))
  }
  # take a final average of our repeats
  final_avg_auc_dff = colMeans(avg_auc_diff_mat_nested_with_microbiome)
  AUC_diff[x_count,] = final_avg_auc_dff
  seAUC_diff[x_count,] <- apply(seAUC_m_n_dff_nested_with_microbiome,2,function(x) sqrt(mean(x,na.rm = TRUE)))
  # add coefficients and sds to lists
  #cox_coef_list[[x_count]] = colMeans(avg_cox_coefs_mat_nested)
  #cox_sd_list[[x_count]] = apply(se_cox_coefs_mat_nested,2,function(x) sqrt(mean(x,na.rm = TRUE)))
}
# create confidence intervals with the standard errors
confup_diff <- create_IC_se_diff(AUC_diff,seAUC_diff,confidencev = 1.96, class = "up")
conflow_diff <- create_IC_se_diff(AUC_diff,seAUC_diff,confidencev = 1.96, class = "low")

# calculate up and down confidence interval for cox regression coefficients

#create_IC_cox_reg <- function(cox_reg_list,cox_reg_sd_list,confidencev=1.96){
#  final_list = list()
#  for(y in 1:length(cox_reg_list)) {
#    cox_reg_vec = cox_reg_list[[y]]
#    cox_reg_sd_vec = cox_reg_sd_list[[y]]
#    mydf = matrix(0,nrow=length(cox_reg_vec),ncol=3)
#    for(x in 1:length(cox_reg_vec)) {
#      coef_temp = cox_reg_vec[x]
#      sd_temp = cox_reg_sd_vec[x]
#      confup = coef_temp + confidencev * sd_temp
#      confdown = coef_temp - confidencev * sd_temp
#      final_vec = c(coef=coef_temp,up=confup,down=confdown)
#      mydf[x,] = final_vec
#    }
#    colnames(mydf) = c("coef","up","down")
#    rownames(mydf) = names(cox_reg_sd_vec)
#    mydf = as.data.frame(mydf)
#    mydf = cbind(name=rownames(mydf),mydf)
#    final_list[[y]] = mydf
#  }
#  return(final_list)
#}
  
#cox_reg_coef_sd_tables = create_IC_cox_reg(cox_coef_list,cox_sd_list)

```

```{r}
# make plot
library(dplyr)
library(tidyr)
library(cowplot)
library(reshape2)

prediction_at = c(0.25,0.6,1,1.5,2,2.5,3)
prediction_for <- c(1,3,5,8)

# set rownames and columnames to the landmark and horizon times
rownames(AUC_diff) <- prediction_at 
colnames(AUC_diff) <- prediction_for
rownames(conflow_diff) <- prediction_at 
colnames(conflow_diff) <- prediction_for
rownames(confup_diff) <- prediction_at 
colnames(confup_diff) <- prediction_for

# put data in wide ggplot format
AUC_diff_melt = melt(AUC_diff)
colnames(AUC_diff_melt) = c("time_from","time_to","AUC_diff")
conflow_diff_melt = melt(conflow_diff)
colnames(conflow_diff_melt) = c("time_from","time_to","low")
confup_diff_melt = melt(confup_diff)
colnames(confup_diff_melt) = c("time_from","time_to","up")

# merge the data frames together
AUC_diff_melt = merge(AUC_diff_melt,conflow_diff_melt,by=c("time_from","time_to"))
AUC_diff_melt = merge(AUC_diff_melt,confup_diff_melt,by=c("time_from","time_to"))
AUC_diff_melt$time_to = as.factor(AUC_diff_melt$time_to)


# now bind the microbiome plus other data and the other data alone together

pdf("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/AUC_diff_comparison_plot.pdf",width=10)
ggplot(AUC_diff_melt, aes(x=time_from,y=AUC_diff)) + geom_point(aes(colour = time_to, shape = time_to),size = 5) + geom_line(aes(colour = time_to),size = 0.5) + geom_ribbon(data = AUC_diff_melt,aes(ymin = low,ymax = up,fill = time_to),alpha = 0.1,show.legend = FALSE, colour = "transparent") + theme_bw()
dev.off()

```



#Make AUC plot with microbiome only data

```{r}
library(dplyr)
library(tidyr)
library(cowplot)
library(reshape2)

prediction_at = c(0.25,0.6,1,1.5,2,2.5,3)
prediction_for <- c(1,3,5,8)

# set rownames and columnames to the landmark and horizon times
rownames(AUC_m_1_microbiome_only) <- prediction_at 
colnames(AUC_m_1_microbiome_only) <- prediction_for
rownames(conflow_microbiome_only) <- prediction_at 
colnames(conflow_microbiome_only) <- prediction_for
rownames(confup_microbiome_only) <- prediction_at 
colnames(confup_microbiome_only) <- prediction_for


# put data in wide ggplot format
AUC_m_1_microbiome_only_melt = melt(AUC_m_1_microbiome_only)
colnames(AUC_m_1_microbiome_only_melt) = c("time_from","time_to","AUC")
conflow_microbiome_only_melt = melt(conflow_microbiome_only)
colnames(conflow_microbiome_only_melt) = c("time_from","time_to","low")
confup_microbiome_only_melt = melt(confup_microbiome_only)
colnames(confup_microbiome_only_melt) = c("time_from","time_to","up")

# merge the data frames together
AUC_m_1_microbiome_only_melt = merge(AUC_m_1_microbiome_only_melt,conflow_microbiome_only_melt,by=c("time_from","time_to"))
AUC_m_1_microbiome_only_melt = merge(AUC_m_1_microbiome_only_melt,confup_microbiome_only_melt,by=c("time_from","time_to"))
AUC_m_1_microbiome_only_melt$time_to = as.factor(AUC_m_1_microbiome_only_melt$time_to)

pdf("AUC_microbiome_only_predictions.pdf")
ggplot(AUC_m_1_microbiome_only_melt, aes(x=time_from,y=AUC)) + geom_point(aes(colour = time_to, shape = time_to),size = 5) + geom_line(aes(colour = time_to),size = 0.5) + geom_ribbon(data = AUC_m_1_microbiome_only_melt,aes(ymin = low,ymax = up,fill = time_to),alpha = 0.1,show.legend = FALSE, colour = "transparent") + theme_bw() + scale_y_continuous(breaks = seq(0.1,1,0.1),limits = c(0.1,1)) + labs(x="",y="") + theme(legend.title=element_text(size=20),legend.text = element_text(size=20))
dev.off()
```

#Also compare microbiome only vs latest

```{r}
AUC_m_1_microbiome_only_melt$predictors = "microbiome"
AUC_m_1_melt_microbiome_only_nature_only = rbind(AUC_m_1_melt,AUC_m_1_microbiome_only_melt)
AUC_m_1_melt_microbiome_only_nature_only$predictors = as.factor(AUC_m_1_melt_microbiome_only_nature_only$predictors)

pdf("~/Dropbox (HMS)/Kostic_Lab/datasets/TEDDY/metagenome_genotype_analysis/AUC_comparison_plot_microbiome_vs_nature.pdf",width=10)
ggplot(AUC_m_1_melt_microbiome_only_nature_only, aes(x=time_from,y=AUC)) + geom_point(aes(colour = time_to, shape = time_to),size = 5) + geom_line(aes(colour = time_to,linetype=predictors),size = 0.5) + geom_ribbon(data = AUC_m_1_with_microbiome_melt,aes(ymin = low,ymax = up,fill = time_to),alpha = 0.1,show.legend = FALSE, colour = "transparent") + theme_bw() + scale_y_continuous(breaks = seq(0,1,0.1),limits = c(0,1)) + labs(x="",y="") + theme(legend.title=element_text(size=20),legend.text = element_text(size=20)) + coord_cartesian(ylim=c(0.5, 1))
dev.off()

```

